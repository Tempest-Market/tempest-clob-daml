module OrderStorage where

import DA.Optional
import qualified DA.Map as M


-- -------------------------
-- Data structures
-- -------------------------
data Order = Order
  with
    owner         : Party
    price         : Decimal
    depositAmount : Decimal
  deriving (Eq, Show)

data OrderStorage = OrderStorage
  with
    -- list[price][id] = nextId (0 if empty)
    list         : M.Map Decimal (M.Map Int Int)
    -- orders[id] = Order
    orders       : M.Map Int (Optional Order)
    -- head[price] = id of head (0 if empty)
    head         : M.Map Decimal Int
    count        : Int         -- last issued id (0 means none yet)
    engine       : Party
    dormantOrder : Optional Order
  deriving (Eq, Show)


-- -------------------------
-- Methods to change the state of the OrderStorage
-- -------------------------

_insertId : OrderStorage -> Decimal -> Int -> Decimal -> OrderStorage
_insertId os price id amount = 
    let headId = fromOptional 0 (M.lookup price os.head)  -- Get head ID, default to 0 (empty)
        orderList = fromOptional M.empty (M.lookup price os.list)
        orders = os.orders
    in
    -- insert order to the linked list
    -- if the list is empty (head ID is 0)
    if headId == 0 || orderList == M.empty then
      let newHead = M.insert price id os.head
          newOrderList = M.insert id 0 orderList  -- Point to 0 (end of list)
          newList = M.insert price newOrderList os.list
      in os with head = newHead; list = newList; orders = orders
    -- traverse in the order list and insert the order
    else
      __traverseAndInsert os price 0 headId amount
      
-- internal internal function to traverse the order list and insert the order in _insertId
__traverseAndInsert : OrderStorage -> Decimal -> Int -> Int -> Decimal -> OrderStorage
__traverseAndInsert os price last headId amount =
  if headId == 0 then
    os
  else
    let
      orderList : M.Map Int Int
      orderList = fromOptional M.empty (M.lookup price os.list)

      nextId : Int
      nextId = fromOptional 0 (M.lookup headId orderList)
    in
    if nextId == 0 then
      -- no order at nextId; treat as end which has been handled in the head case
      os
    else
      case M.lookup nextId os.orders of
        -- if next order exists, ordering between nextOrder based on amount is determined
        Some (Some nextOrder) ->
          let nextAmount = nextOrder.depositAmount
          in
          case compare amount nextAmount of
            -- if next order amount is less than the nextAmount, traverse until you find the next order that is less than the amount 
            LT ->
              let last = headId
              in __traverseAndInsert os price last nextId amount
            -- if next order amount is equal to the amount insert the order after nextOrder
            EQ ->
              let 
                nextNextId: Int
                nextNextId = fromOptional 0 (M.lookup nextId orderList)
                orderList' = M.insert headId nextNextId orderList 
                orderList'' = M.insert nextId headId orderList'
                newList = M.insert price orderList'' os.list
              in os with list = newList
            -- if next order amount is greater than the amount insert the order, insert the order before nextOrder
            GT ->
              if nextAmount == 0.0 then
                -- Insert order at the end of the list
                let
                  priceHead = fromOptional 0 (M.lookup price os.head)
                  orderList' = M.insert priceHead headId orderList
                  orderList'' = M.insert headId 0 orderList'
                  newList = M.insert price orderList'' os.list
                in os with list = newList
              else 
                -- Insert order at the in the middle of the list
                let
                  orderList' = M.insert last headId orderList
                  orderList'' = M.insert headId nextId orderList'
                  newList = M.insert price orderList'' os.list
                in os with list = newList
        _ ->
          -- no order at nextId; treat as end which has been handled in the head case
          os

             


-- front pop Id from the order storage
__fpopId: OrderStorage -> Decimal -> Int
__fpopId os price =
  -- get first order from the price
  let
    first = fromOptional 0 (M.lookup price os.head)
  in
  first

-- front pop handle head from the order storage
__fpopOS: OrderStorage -> Decimal -> OrderStorage
__fpopOS os price =
  let
    first = __fpopId os price
  in
  if first == 0 then
    os
  else
    let
      orderList = fromOptional M.empty (M.lookup price os.list)
      nextId = fromOptional 0 (M.lookup first orderList)
      -- set next Id as os.head[price]
      newHead = M.insert price nextId os.head
      -- delete the first order from the order list
      newOrderList = M.delete first orderList
      newList = M.insert price newOrderList os.list
    in os with head = newHead; list = newList

_fpop: OrderStorage -> Decimal -> (Int, OrderStorage)
_fpop os price =
  let
    first = __fpopId os price
  in
  if first == 0 then
    (0, os)
  else
    let
      newOS = __fpopOS os price
    in
    (first, newOS)



_createOrder: OrderStorage -> Party -> Decimal -> Decimal -> (Int, Bool, OrderStorage)
_createOrder os pty price depositAmount = 
   -- assertMsg "price must be positive" (price > 0.0)
   -- create order
   let 
    newOrder = Order with owner=pty; price=price; depositAmount=depositAmount
    foundDmt = False
    -- max int in daml is 2^63 - 1 = 9223372036854775807
    newCount = if os.count == 0 || os.count == 9223372036854775807 then
      1 else os.count+1
    orderList = fromOptional M.empty (M.lookup price os.list)
    oldOrderId = fromOptional 0 (M.lookup os.count orderList)
   in 
    -- check if the order already exists
    if orderList /= M.empty && oldOrderId /= 0 then
      -- store canceling order to dormant order 
      let 
        oldOrder: Optional Order
        oldOrder = fromOptional None (M.lookup oldOrderId os.orders)
        -- TODO: add delete order method and insert the order
        -- os' = _deleteOrder
        -- TODO: insert new order from the removed order
        newOrders = os.orders
        os' = os with orders=newOrders; count=newCount; dormantOrder=oldOrder
        foundDmt = True
      in (newCount, True, os')
    else
      -- insert order
      let 
        newOrders = M.insert newCount (Some newOrder) os.orders
      in (newCount, False, os with orders=newOrders)


_deleteOrder: OrderStorage -> Int -> OrderStorage
_deleteOrder os id =
  let
    orderList = fromOptional M.empty (M.lookup os.price os.list)
    newOrderList = M.delete id orderList
    newList = M.insert os.price newOrderList os.list
  in os with list = newList