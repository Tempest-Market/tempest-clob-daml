module OrderStorage where

import DA.Optional
import qualified DA.Map as M


-- -------------------------
-- Data structures
-- -------------------------
data Order = Order
  with
    owner         : Party
    price         : Decimal
    depositAmount : Decimal
  deriving (Eq, Show)

data OrderStorage = OrderStorage
  with
    -- list[price][id] = nextId (0 if empty)
    list         : M.Map Decimal (M.Map Int Int)
    -- orders[id] = Order
    orders       : M.Map Int Order
    -- head[price] = id of head (0 if empty)
    head         : M.Map Decimal Int
    count        : Int         -- last issued id (0 means none yet)
    engine       : Party
    dormantOrder : Optional Order
  deriving (Eq, Show)


test: Int -> Int -> Int
test a b = a + b


-- -------------------------
-- Methods to change the state of the OrderStorage
-- -------------------------

_insertId : OrderStorage -> Decimal -> Int -> Decimal -> OrderStorage
_insertId os price id amount = 
    let headId = fromOptional 0 (M.lookup price os.head)  -- Get head ID, default to 0 (empty)
        orderList = fromOptional M.empty (M.lookup price os.list)
        orders = os.orders
    in
    -- insert order to the linked list
    -- if the list is empty (head ID is 0)
    if headId == 0 || orderList == M.empty then
      let newHead = M.insert price id os.head
          newOrderList = M.insert id 0 orderList  -- Point to 0 (end of list)
          newList = M.insert price newOrderList os.list
      in os with head = newHead; list = newList; orders = orders
    -- traverse in the order list and insert the order
    else
      __traverseAndInsert os price headId amount
      
-- internal internal function to traverse the order list and insert the order in _insertId
__traverseAndInsert : OrderStorage -> Decimal -> Int -> Decimal -> OrderStorage
__traverseAndInsert os price headId amount =
  if headId == 0 then
    os
  else
    let
      orderList : M.Map Int Int
      orderList = fromOptional M.empty (M.lookup price os.list)

      nextId : Int
      nextId = fromOptional 0 (M.lookup headId orderList)
    in
    if nextId == 0 then
      -- TODO: no order at nextId; treat as end
      os
    else
      case M.lookup nextId os.orders of
        None ->
          -- no order at nextId; treat as end
          os
        -- if next order exists, ordering between nextOrder based on amount is determined
        Some nextOrder ->
          let nextAmount = nextOrder.depositAmount
          in
          case compare nextAmount amount of
            -- if next order amount is less than the amount insert the order before nextOrder
            LT ->
              os
            -- if next order amount is equal to the amount insert the order after nextOrder
            EQ ->
              os
            -- if next order amount is greater than the amount insert the order, traverse until you find the next order that is less than the amount
            GT ->
              _traverseAndInsert os price nextId amount




